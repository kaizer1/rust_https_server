#![deny(warnings)]

//use std::convert::Infallible;

use tokio::fs::File;
use std::time::{ Instant };
use tokio_util::codec::{BytesCodec, FramedRead};
//use tokio::prelude::Future;

use futures_util::TryStreamExt;

//use value::JsonValue::Null;
//use json::JsonValue;
use hyper::service::{make_service_fn, service_fn};
use hyper::{Body, Method, Request, Response, Server, StatusCode};
//use tokio_postgres::{NoTls};
extern crate timer;
extern crate chrono;
//use std::fs;
//use serde_json::{Result, Value};
//use std::fs::OpenOptions;
//use std::io;
//use std::io::prelude::*;
//use std::os::unix;
//use std::path::Path;



use std::sync::mpsc::channel;
use core::lazy::Lazy;

static mut DF_K : bool = false;

static INDEX: &str = "my.html";
static NOTFOUND: &[u8] = b"Not Found";


fn not_found() -> Response<Body> {
    Response::builder()
        .status(StatusCode::NOT_FOUND)
        .body(NOTFOUND.into())
        .unwrap()
}


//async fn send_files() ->Result<Response<Body>, hyper::Error> {
  //   println!(" send data to html pages ");
  
    // let mut builder = Response::builder()
    // .header("Fsld","losdd")
    // .status(StatusCode::OK);
     
     //let full_body = body.map_err(|_| ()).fold(vec![], |mut acc, chunk| {
      //    acc.extend_from_slice(&chunk);
    //            Ok(acc)
  //}).await.and_then(|v| String::from_utf8(v).map_err(|_| ())).unwrap();
   // let user_json: serde_json::Value = serde_json::from_str(&full_body).unwrap();
   // let token = core_api::api_get_token(
   // serde::to_string(&user_json["user"]).unwrap(),
   // serde::to_string(&user_json["password"]).unwrap(), 
   //);
  

 //let data = r#"
       // {
         //   "name": "John Doe",
         //   "age": 43,
         //   "phones": [
         //       "+44 1234567",
         //       "+44 2345678"
       //     ]
      //  }"#;

    // Parse the string of data into serde_json::Value.
   // let v: Value = serde_json::from_str(data)?;  
 
    
 //  let responce = Response::builder()
 	//.status(200)
   //     .header("x-los", "LOS-Ok")
   //     .body(())
   //     .unwrap();
 
    
  // Ok(Response::new(Body::from("return another")))
  //    return Ok(responce);
 //return Ok(Response::new().with_status(StatusCode::Created).body());
 
// } 


static SUPERNOW : Lazy<Instant> = Lazy::new(|| {
  
     let mut m = Instant::new();
 
});


async fn read_los_body(res: Request<Body>) -> Result<Response<Body>, hyper::Error> {
   let bytes = hyper::body::to_bytes(res.into_body()).await?;
   let simplestring = String::from_utf8(bytes.to_vec());
   println!(" simple send's {:?} ", simplestring);
 

   let start = Instant::now();

 
 // OK(Response::new(Body::from("call very well")))
 
let mut datajson = json::JsonValue::new_object();
 datajson["answer"] = 42.into();
 datajson["fooLos"] = "var".into();
   
    let duration = start.elapsed();

   println!("TIme elapsed in {:?} ", duration.as_secs());
    println!("  time to start program = {:?}" , start.duration_since(SUPERNOW));
  Ok(Response::new(Body::from(datajson.dump())))

}

async fn simple_file_send(filename: &str) -> Result<Response<Body>, hyper::Error> {
    // Serve a file by asynchronously reading it by chunks using tokio-util crate.
     println!(" calling simple file send {}", filename);         
  
      //let task = File::open(filename).await.and_then(|file| {
     //    println!("open A");
   // }).map_err(|e| { 
   //eprintln!("IO error: {:?}", e);
   // });
 
 
 //  match fs::create_dir("a") {
 //       Err(why) => println!("! {:?}", why.kind()),
 //       Ok(_) => {},
 //   } 
 

    // let f = File::open(filename).await;
 
    // let _f = match f {
    //   Ok(file) => file,
   //    Err(error) => panic!(" problem is open file: {:?}", error),
   // };

     
  
    if let Ok(file) = File::open(filename).await {
         println!(" open send my files ! ");
        let stream = FramedRead::new(file, BytesCodec::new());
        let body = Body::wrap_stream(stream);
        return Ok(Response::new(body));
    } else {
      println!(" eror ! ");  
   } 
     

    Ok(not_found())
}




async fn echo(req: Request<Body>) -> Result<Response<Body>, hyper::Error>{
              println!(" request start ! ");
      match (req.method(), req.uri().path()) {
        // Serve some instructions at /
 
    (&Method::GET, "/") | (&Method::GET, "/index.nginx-debian.html") => simple_file_send(INDEX).await,
  
      (&Method::GET, "/no_file.html") => {
                 println!(" we are in no exists ");  
            simple_file_send("this_file_not_exists.html").await
         }
         
   
      //  (&Method::GET, "/") => Ok(Response::new(Body::from(
       //     "Try POSTing data to /echo such as: `curl localhost:3000/echo -XPOST -d 'hello world'`",
      //  ))),
 
     //(&Method::GET, "/post") => send_files().await,

    
        // Simply echo the body back to the client.
        (&Method::POST, "/echo") => read_los_body(req).await,
    // {
          //  println!(" calling simple echo ! ");
         //   println!(" in my body = {:?}", &req.into_body());
       // Ok(Response::new(Body::from("simple call")))
      //   Ok(Response::new(req.into_body()))
        // },

           (&Method::POST, "/ehi") => {

                   unsafe {
                      if DF_K {
                          println!(" ok TRUE my values !");
                      } else {

              println!(" False (default )calliung EHI is besting's ");
                        }

                     }

  // let mut builder = Response::builder()
                 //     .header("LOSDFF", "BASDRAN");
                      //.status(STATUS::OK);

                        // builder.body()

                 let respom = Response::builder();
                respom.header("Ff", "ddslkfjwk jjakskw ")
                 .status(StatusCode::OK);

                  //respom.body(())

               Ok(Response::new(Body::from("private_key_values")))

            },
        // Convert to uppercase before sending back to client using a stream.
        (&Method::POST, "/echo/uppercase") => {
             println!(" in a post/echo/uppercase KSD !");
            let chunk_stream = req.into_body().map_ok(|chunk| {
                chunk
                    .iter()
                    .map(|byte| byte.to_ascii_uppercase())
                    .collect::<Vec<u8>>()
            });
            Ok(Response::new(Body::wrap_stream(chunk_stream)))
        }

        


        (&Method::POST, "/echo/reversed") => {
            let whole_body = hyper::body::to_bytes(req.into_body()).await?;


         let reversed_body = whole_body.iter().rev().cloned().collect::<Vec<u8>>();
            Ok(Response::new(Body::from(reversed_body)))
        }

        // Return the 404 Not Found for other routes.
        _ => {
                println!(" not los found ! ");
            let mut not_found = Response::default();
            *not_found.status_mut() = StatusCode::NOT_FOUND;
            Ok(not_found)
        }
    }
}

//async fn hello(_: Request<Body>) -> Result<Response<Body>, Infallible> {
//    Ok(Response::new(Body::from("Hello World!")))
//}

// was Result<(), Box<dyn std::error::Error + Send + Sync>>
#[tokio::main]
pub async fn main() -> Result<(),  Box<dyn std::error::Error + Send + Sync>> {
    pretty_env_logger::init();

    // For every connection, we must make a `Service` to handle all
    // incoming HTTP requests on said connection.
    //let make_svc = make_service_fn(|_conn| {
        // This is the `Service` that will handle the connection.
        // `service_fn` is a helper to convert a function that
        // returns a Response into a `Service`.
    //     println!(" make connection ");
  //      async { Ok::<_, Infallible>(service_fn(hello)) }
//    });

 
    let timer = timer::Timer::new();
    let (tx, rx) = channel();

  //  let(_client, connection) = tokio_postgres::connect("host=localhost user=postgres password=lospass2", NoTls).await?;
  
   //tokio::spawn(async move {
     //  if let Err(e) = connection.await {
       //    println!( " connection error = {}" , e);
    //}
   //});
 
   let _guard = timer.schedule_with_delay(chrono::Duration::seconds(17), move || {
    let _ignored = tx.send(());
 });


   let service = make_service_fn(|_| async { Ok::<_, hyper::Error>(service_fn(echo))});

   // was [127, 0, 0, 1], 3000)
    let addr = ([127, 0, 0, 1], 3000).into();

    let server = Server::bind(&addr).serve(service);


    println!("Listening on http://{}", addr);



    server.await?;

    rx.recv().unwrap();
   unsafe {
    DF_K = true;
 }
    //df_k1 = true;


    Ok(())
}
